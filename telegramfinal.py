# -*- coding: utf-8 -*-
"""TelegramFinal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C5WuXVWFMGxh9XhoVVxwoDTbVgTgxTT0
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install ultralytics  # Ensure YOLO is installed

from ultralytics import YOLO
import os
import shutil

!pip install pydrive google-auth google-auth-oauthlib google-auth-httplib2
!pip install pyTelegramBotAPI PyDrive2
!pip install -U PyDrive

import os

# ğŸ”¹ Define Image Folder in Drive
image_folder = "/content/drive/My Drive/Telegram_Images"
os.makedirs(image_folder, exist_ok=True)

print(f"âœ… Save images in: {image_folder}")

!pip install pydrive2

!pip install googletrans==4.0.0-rc1

import telebot
import requests
import threading
import os
import requests
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
from pydrive2.auth import GoogleAuth
from pydrive2.drive import GoogleDrive
from oauth2client.service_account import ServiceAccountCredentials
import cv2
import torch
import numpy as np
import json
from ultralytics import YOLO
from telebot import types
from googletrans import Translator


# Bot Token & Google Drive Folder ID
BOT_TOKEN = "8187455463:AAG-XxnkDc4tKNXywjsB_mfP3abpA1zDKWg"
FOLDER_ID = "1IxeQ04Wxk3AAurdxULC3TCCU-HDoOaVt"

bot = telebot.TeleBot(BOT_TOKEN)

# Authenticate Google Drive
json_key_path = "/content/drive/MyDrive/happyfarmbzubotproject-fca5f1cb527a.json"
scope = ["https://www.googleapis.com/auth/drive"]
creds = ServiceAccountCredentials.from_json_keyfile_name(json_key_path, scope)
gauth = GoogleAuth()
gauth.credentials = creds
drive = GoogleDrive(gauth)

print("\u2705 Google Drive authentication successful!")

# Global storage for user data
user_choices = {}   # plant type
sensor_values = {}  # sensor JSON
user_languages = {} # Store user language preferences


def get_sensor_data_from_drive():
    try:
        # Create a file object by fileId (the fileId from your ESP code)
        sensor_file = drive.CreateFile({'id': '1nB0K5Qrhf3XcwT9_WpSg-4RhmfEnPNRq'})
        sensor_file.GetContentFile('sensorData.json')

        # Load the sensor data from the downloaded file
        with open('sensorData.json', 'r') as file:
            sensor_data = json.load(file)
        return sensor_data
    except Exception as e:
        print("âŒ Error fetching sensor data:", e)
        return None

# --- Define Models and Disease Info ---


models = {
    "Lettuce": {
        "path": "/content/drive/MyDrive/Datasets/LettuceDataset/LettuceResults/best.pt",
        "classes": [
            "Bacterial", "Downy_mildew_on_lettuce", "Lettuce Mosaic Virus",
            "Powdery_mildew_on_lettuce", "Septoria_Blight_on_lettuce",
            "Wilt and leaf blight on lettuce", "healthy"
        ]
    },
    "Cucumber": {
        "path": "/content/drive/MyDrive/Datasets/CucumberDataset/best.pt",
        "classes": ["Anthracnose", "Bacterial Wilt", "Downy Mildew", "Fresh Leaf", "Gummy Stem Blight","Powdery Mildew"]
    },
    "Tomato": {
        "path": "/content/drive/MyDrive/Datasets/TomatoDataset/tomatoResult/bestTomato.pt",
        "classes": [ "Gray spot", "powdery mildew", "Tomato___Bacterial_spot", "Tomato___Early_blight", "Tomato___healthy", "Tomato___Late_blight", "Tomato___Leaf_Mold", "Tomato___Septoria_leaf_spot"]
    }
}

disease_info = {
    "Bacterial": {
        "name_ar": "Ø§Ù„Ù…Ø±Ø¶ Ø§Ù„Ø¨ÙƒØªÙŠØ±ÙŠ",
        "description_en": "A bacterial disease that causes yellowing, wilting, and necrosis in lettuce. ğŸŒ¿âš ï¸",
        "cause_en": "Caused by bacterial pathogens such as Xanthomonas spp. or Pseudomonas spp. ğŸ¦ ",
        "treatment_en": "Use copper-based fungicides, remove infected leaves, and avoid overhead watering. ğŸ’§âŒ",
        "description_ar": "Ù…Ø±Ø¶ Ø¨ÙƒØªÙŠØ±ÙŠ ÙŠØ³Ø¨Ø¨ Ø§Ù„Ø§ØµÙØ±Ø§Ø± ÙˆØ§Ù„Ø°Ø¨ÙˆÙ„ ÙˆØ§Ù„Ù†Ø®Ø± ÙÙŠ Ø®Ø³. ğŸŒ¿âš ï¸",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ø¨ÙƒØªÙŠØ±ÙŠØ© Ù…Ø«Ù„ Xanthomonas spp. Ø£Ùˆ Pseudomonas spp. ğŸ¦ ",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„Ù†Ø­Ø§Ø³ÙŠØ©ØŒ ÙˆØ§Ø²Ø§Ù„Ø© Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ù…ØµØ§Ø¨Ø©ØŒ ÙˆØªØ¬Ù†Ø¨ Ø§Ù„Ø±ÙŠ Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰. ğŸ’§âŒ"
    },
    "Downy_mildew_on_lettuce": {
        "name_ar": "Ø§Ù„Ø¹ÙÙ† Ø§Ù„Ø²ØºØ¨ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø³",
        "description_en": "A fungal disease that causes yellowing and downy spots on the underside of lettuce leaves. ğŸ‚ğŸŒ±",
        "cause_en": "Caused by the oomycete pathogen Peronospora farinosa. ğŸ„",
        "treatment_en": "Use fungicides, improve air circulation, and remove infected plant parts. ğŸƒğŸ’¨",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ³Ø¨Ø¨ Ø§Ù„Ø§ØµÙØ±Ø§Ø± ÙˆØ§Ù„Ø¨Ù‚Ø¹ Ø§Ù„ÙØ±ÙˆÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø³ÙÙ„ÙŠ Ù„Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø®Ø³. ğŸ‚ğŸŒ±",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Ø§Ù„Ø¹ÙŠØ´ÙŠØ© Peronospora farinosa. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ©ØŒ ÙˆØ­Ø³Ù† Ø§Ù„ØªÙ‡ÙˆÙŠØ©ØŒ ÙˆØ§Ø²Ø§Ù„Ø© Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…ØµØ§Ø¨Ø© Ù…Ù† Ø§Ù„Ù†Ø¨Ø§Øª. ğŸƒğŸ’¨"
    },
    "Lettuce_Mosaic_Virus": {
        "name_ar": "ÙÙŠØ±ÙˆØ³ Ù…ÙˆØ²Ø§ÙŠÙŠÙƒ Ø§Ù„Ø®Ø³",
        "description_en": "A viral disease causing mosaic-like symptoms on lettuce leaves. ğŸƒğŸ’”",
        "cause_en": "Caused by the Lettuce mosaic virus (LMV). ğŸ¦ ",
        "treatment_en": "Remove infected plants and use resistant varieties. ğŸš«ğŸŒ±",
        "description_ar": "Ù…Ø±Ø¶ ÙÙŠØ±ÙˆØ³ÙŠ ÙŠØ³Ø¨Ø¨ Ø£Ø¹Ø±Ø§Ø¶ ØªØ´Ø¨Ù‡ Ø§Ù„ÙØ³ÙŠÙØ³Ø§Ø¡ Ø¹Ù„Ù‰ Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø®Ø³. ğŸƒğŸ’”",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙÙŠØ±ÙˆØ³Ø§Øª Ù…Ù† Ù†ÙˆØ¹ Lettuce mosaic virus (LMV). ğŸ¦ ",
        "treatment_ar": "Ù‚Ù… Ø¨Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù†Ø¨Ø§ØªØ§Øª Ø§Ù„Ù…ØµØ§Ø¨Ø© ÙˆØ§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£ØµÙ†Ø§Ù Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©. ğŸš«ğŸŒ±"
    },
    "Powdery_mildew_on_lettuce": {
        "name_ar": "Ø§Ù„Ø¨ÙŠØ§Ø¶ Ø§Ù„Ø¯Ù‚ÙŠÙ‚ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø³",
        "description_en": "A fungal disease that forms a white powdery coating on the tops of lettuce leaves. â„ï¸ğŸƒ",
        "cause_en": "Caused by the fungus Erysiphe cichoracearum. ğŸ„",
        "treatment_en": "Use fungicides and ensure proper spacing to avoid high humidity. ğŸŒ¬ï¸ğŸ’§",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ´ÙƒÙ„ Ø·Ø¨Ù‚Ø© Ø¨ÙŠØ¶Ø§Ø¡ Ø¨ÙˆØ¯Ø±ÙŠØ© Ø¹Ù„Ù‰ Ø£Ø¹Ù„Ù‰ Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø®Ø³. â„ï¸ğŸƒ",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Erysiphe cichoracearum. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ© ÙˆØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…Ø³Ø§ÙØ§Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø±Ø·ÙˆØ¨Ø© Ø§Ù„Ø¹Ø§Ù„ÙŠØ©. ğŸŒ¬ï¸ğŸ’§"
    },
    "Septoria_Blight_on_lettuce": {
        "name_ar": "Ø§Ù„Ù„ÙØ­Ø© Ø§Ù„Ø³Ø¨ØªÙŠÙˆØ±ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø³",
        "description_en": "A fungal disease causing lesions with dark edges on lettuce leaves. ğŸ¥¬âš ï¸",
        "cause_en": "Caused by the fungus Septoria spp. ğŸ„",
        "treatment_en": "Remove affected leaves and apply fungicides. ğŸ‚ğŸ”¬",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ³Ø¨Ø¨ Ø§Ù„ØªÙ‚Ø±Ø­Ø§Øª Ø°Ø§Øª Ø§Ù„Ø­ÙˆØ§Ù Ø§Ù„Ø¯Ø§ÙƒÙ†Ø© Ø¹Ù„Ù‰ Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø®Ø³. ğŸ¥¬âš ï¸",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Ù…Ù† Ù†ÙˆØ¹ Septoria spp. ğŸ„",
        "treatment_ar": "Ù‚Ù… Ø¨Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ù…ØµØ§Ø¨Ø© ÙˆØ·Ø¨Ù‚ Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ©. ğŸ‚ğŸ”¬"
    },
    "Wilt_and_leaf_blight_on_lettuce": {
        "name_ar": "Ø§Ù„Ø°Ø¨ÙˆÙ„ ÙˆÙ„ÙØ­Ø© Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø³",
        "description_en": "A disease that causes wilting and browning of lettuce leaves. ğŸŒ¿ğŸ’”",
        "cause_en": "Caused by various pathogens, including Fusarium wilt and bacterial wilt. ğŸ¦ ",
        "treatment_en": "Remove infected plants, apply appropriate fungicides, and improve soil drainage. ğŸŒ±ğŸ’§",
        "description_ar": "Ù…Ø±Ø¶ ÙŠØ³Ø¨Ø¨ Ø°Ø¨ÙˆÙ„ ÙˆØªØ­ÙˆÙ„ Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø®Ø³ Ø¥Ù„Ù‰ Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø¨Ù†ÙŠ. ğŸŒ¿ğŸ’”",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø¹Ø¯Ø© Ø¹ÙˆØ§Ù…Ù„ Ù…Ù…Ø±Ø¶Ø© Ø¨Ù…Ø§ ÙÙŠ Ø°Ù„Ùƒ Ø°Ø¨ÙˆÙ„ Fusarium ÙˆØ°Ø¨ÙˆÙ„ Ø¨ÙƒØªÙŠØ±ÙŠ. ğŸ¦ ",
        "treatment_ar": "Ù‚Ù… Ø¨Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù†Ø¨Ø§ØªØ§Øª Ø§Ù„Ù…ØµØ§Ø¨Ø©ØŒ ÙˆØ·Ø¨Ù‚ Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©ØŒ ÙˆØ­Ø³Ù† ØªØµØ±ÙŠÙ Ø§Ù„ØªØ±Ø¨Ø©. ğŸŒ±ğŸ’§"
    },
    "healthy": {
        "name_ar": "Ø§Ù„Ù†Ø¨Ø§Øª Ø³Ù„ÙŠÙ…",
        "description_en": "The plant is healthy and free of any visible diseases. ğŸŒ±âœ…",
        "cause_en": "N/A",
        "treatment_en": "Continue normal care and monitoring. ğŸŒğŸŒ¿",
        "description_ar": "Ø§Ù„Ù†Ø¨Ø§Øª ØµØ­ÙŠ ÙˆØ®Ø§Ù„ÙŠ Ù…Ù† Ø£ÙŠ Ø£Ù…Ø±Ø§Ø¶ Ø¸Ø§Ù‡Ø±Ø©. ğŸŒ±âœ…",
        "cause_ar": "ØºÙŠØ± Ù…ØªØ§Ø­",
        "treatment_ar": "Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ø¹Ù†Ø§ÙŠØ© Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ© ÙˆØ§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©. ğŸŒğŸŒ¿"
    },


    # Cucumber diseases

    "Anthracnose": {
        "name_ar": "Ø§Ù„Ø£Ù†Ø«Ø±Ø§ÙƒÙ†ÙˆØ²",
        "description_en": "A fungal disease that causes sunken lesions and dark spots on leaves and fruits. ğŸˆâš ï¸",
        "cause_en": "Caused by the fungus Colletotrichum spp. ğŸ„",
        "treatment_en": "Use fungicides, remove infected plants, and rotate crops to reduce spread. ğŸ”„ğŸ¦ ",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ³Ø¨Ø¨ ØªÙ‚Ø±Ø­Ø§Øª ØºØ§Ø¦Ø±Ø© ÙˆØ¨Ù‚Ø¹ Ø¯Ø§ÙƒÙ†Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ ÙˆØ§Ù„ÙÙˆØ§ÙƒÙ‡. ğŸˆâš ï¸",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Ù…Ù† Ù†ÙˆØ¹ Colletotrichum spp. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ©ØŒ ÙˆØ§Ø²Ø§Ù„Ø© Ø§Ù„Ù†Ø¨Ø§ØªØ§Øª Ø§Ù„Ù…ØµØ§Ø¨Ø©ØŒ ÙˆØ¯ÙˆØ± Ø§Ù„Ù…Ø­Ø§ØµÙŠÙ„ Ù„Ù„Ø­Ø¯ Ù…Ù† Ø§Ù„Ø§Ù†ØªØ´Ø§Ø±. ğŸ”„ğŸ¦ "
    },
    "Bacterial Wilt": {
        "name_ar": "Ø§Ù„Ø°Ø¨ÙˆÙ„ Ø§Ù„Ø¨ÙƒØªÙŠØ±ÙŠ",
        "description_en": "A bacterial infection that causes yellowing, wilting, and rapid collapse of cucumber plants. ğŸŒ¿âš ï¸",
        "cause_en": "Caused by the bacterium Erwinia tracheiphila. ğŸ¦ ",
        "treatment_en": "Remove infected plants and use resistant cucumber varieties. âŒğŸŒ±",
        "description_ar": "Ø¹Ø¯ÙˆÙ‰ Ø¨ÙƒØªÙŠØ±ÙŠØ© ØªØ³Ø¨Ø¨ Ø§ØµÙØ±Ø§Ø±ØŒ Ø°Ø¨ÙˆÙ„ØŒ ÙˆØ§Ù†Ù‡ÙŠØ§Ø± Ø³Ø±ÙŠØ¹ Ù„Ù†Ø¨Ø§ØªØ§Øª Ø§Ù„Ø®ÙŠØ§Ø±. ğŸŒ¿âš ï¸",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡Ø§ Ø§Ù„Ø¨ÙƒØªÙŠØ±ÙŠØ§ Erwinia tracheiphila. ğŸ¦ ",
        "treatment_ar": "Ù‚Ù… Ø¨Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù†Ø¨Ø§ØªØ§Øª Ø§Ù„Ù…ØµØ§Ø¨Ø© ÙˆØ§Ø³ØªØ®Ø¯Ù… Ø£ØµÙ†Ø§Ù Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©. âŒğŸŒ±"
    },
    "Downy Mildew": {
        "name_ar": "Ø§Ù„Ø¨ÙŠØ§Ø¶ Ø§Ù„Ø²ØºØ¨ÙŠ",
        "description_en": "A fungal disease that causes yellow spots on the upper leaf surfaces and a grayish mold underneath. ğŸ‚ğŸ¦ ",
        "cause_en": "Caused by the fungus Pseudoperonospora cubensis. ğŸ„",
        "treatment_en": "Apply fungicides, remove affected leaves, and improve air circulation. ğŸ’¨ğŸŒ¿",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ³Ø¨Ø¨ Ø¨Ù‚Ø¹ ØµÙØ±Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø³Ø·Ø­ Ø§Ù„Ø¹Ù„ÙŠØ§ Ù„Ù„Ø£ÙˆØ±Ø§Ù‚ ÙˆØ¹ÙÙ† Ø±Ù…Ø§Ø¯ÙŠ Ù…Ù† Ø§Ù„Ø£Ø³ÙÙ„. ğŸ‚ğŸ¦ ",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Pseudoperonospora cubensis. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ©ØŒ ÙˆØ£Ø²Ù„ Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ù…ØµØ§Ø¨Ø©ØŒ ÙˆØ­Ø³Ù† Ø§Ù„ØªÙ‡ÙˆÙŠØ©. ğŸ’¨ğŸŒ¿"
    },
    "Fresh Leaf": {
         "name_ar": "ÙˆØ±Ù‚Ø© ØµØ­ÙŠØ©",
        "description_en": "Healthy leaves that are free from disease. ğŸŒ±ğŸ˜Š",
        "cause_en": "N/A",
        "treatment_en": "Continue proper care to maintain healthy plants. ğŸŒ¿ğŸ’§",
        "description_ar": "Ø£ÙˆØ±Ø§Ù‚ ØµØ­ÙŠØ© Ø®Ø§Ù„ÙŠØ© Ù…Ù† Ø§Ù„Ø£Ù…Ø±Ø§Ø¶. ğŸŒ±ğŸ˜Š",
        "cause_ar": "Ù„Ø§ ÙŠÙˆØ¬Ø¯",
        "treatment_ar": "Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ø¹Ù†Ø§ÙŠØ© Ø§Ù„Ø³Ù„ÙŠÙ…Ø© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨Ø§ØªØ§Øª Ø§Ù„ØµØ­ÙŠØ©. ğŸŒ¿ğŸ’§"
    },
    "Gummy Stem Blight": {
        "name_ar": "Ù„ÙØ­Ø© Ø§Ù„Ø³Ø§Ù‚ Ø§Ù„ØµÙ…ØºÙŠØ©",
        "description_en": "A fungal disease that causes lesions and gummy exudates on stems and leaves. ğŸŒ¿ğŸ’§",
        "cause_en": "Caused by the fungus Didymella bryoniae. ğŸ„",
        "treatment_en": "Use fungicides and remove infected plants to prevent spread. ğŸ¦ âŒ",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ³Ø¨Ø¨ ØªÙ‚Ø±Ø­Ø§Øª ÙˆØ¥ÙØ±Ø§Ø²Ø§Øª Ù„Ø²Ø¬Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠÙ‚Ø§Ù† ÙˆØ§Ù„Ø£ÙˆØ±Ø§Ù‚. ğŸŒ¿ğŸ’§",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Didymella bryoniae. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ© ÙˆØ£Ø²Ù„ Ø§Ù„Ù†Ø¨Ø§ØªØ§Øª Ø§Ù„Ù…ØµØ§Ø¨Ø© Ù„Ù…Ù†Ø¹ Ø§Ù„Ø§Ù†ØªØ´Ø§Ø±. ğŸ¦ âŒ"
    },
    "Powdery Mildew": {
        "name_ar": "Ø§Ù„Ø¨ÙŠØ§Ø¶ Ø§Ù„Ø¯Ù‚ÙŠÙ‚ÙŠ",
        "description_en": "A fungal disease that appears as white, powdery spots on leaves, stems, and sometimes fruits. ğŸ‚ğŸŒ¨ï¸",
        "cause_en": "Caused by the fungus Podosphaera xanthii. ğŸ„",
        "treatment_en": "Apply fungicides and ensure good air circulation by proper plant spacing. ğŸ’¨ğŸŒ±",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ¸Ù‡Ø± Ø¹Ù„Ù‰ Ø´ÙƒÙ„ Ø¨Ù‚Ø¹ Ø¨ÙŠØ¶Ø§Ø¡ ÙˆÙ…Ø³Ø­ÙˆÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ ÙˆØ§Ù„Ø³ÙŠÙ‚Ø§Ù† ÙˆØ£Ø­ÙŠØ§Ù†Ù‹Ø§ Ø§Ù„ÙÙˆØ§ÙƒÙ‡. ğŸ‚ğŸŒ¨ï¸",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Podosphaera xanthii. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ© ÙˆØªØ£ÙƒØ¯ Ù…Ù† ØªÙˆÙÙŠØ± Ø§Ù„ØªÙ‡ÙˆÙŠØ© Ø§Ù„Ø¬ÙŠØ¯Ø© Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§ÙØ§Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ø¨ÙŠÙ† Ø§Ù„Ù†Ø¨Ø§ØªØ§Øª. ğŸ’¨ğŸŒ±"
    },

    # Tomato diseases
    "Gray spot": {
        "name_ar": "Ø§Ù„Ø¨Ù‚Ø¹Ø© Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠØ©",
        "description_en": "A fungal disease that causes grayish-brown lesions on tomato leaves and stems. ğŸ…ğŸ¦ ",
        "cause_en": "Caused by the fungus Alternaria solani. ğŸ„",
        "treatment_en": "Use fungicides and practice crop rotation to avoid reinfection. ğŸ”„ğŸŒ¿",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ³Ø¨Ø¨ ØªÙ‚Ø±Ø­Ø§Øª Ø¨Ù†ÙŠÙ‘Ø© Ø±Ù…Ø§Ø¯ÙŠØ© Ø¹Ù„Ù‰ Ø£ÙˆØ±Ø§Ù‚ ÙˆØ³ÙŠÙ‚Ø§Ù† Ø§Ù„Ø·Ù…Ø§Ø·Ù…. ğŸ…ğŸ¦ ",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Alternaria solani. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ© ÙˆØ§ØªØ¨Ø§Ø¹ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø­Ø§ØµÙŠÙ„ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙ„ÙˆØ« Ø§Ù„Ù…ØªÙƒØ±Ø±. ğŸ”„ğŸŒ¿"
    },
    "Powdery mildew": {
        "name_ar": "Ø§Ù„Ø¨ÙŠØ§Ø¶ Ø§Ù„Ø¯Ù‚ÙŠÙ‚ÙŠ",
        "description_en": "A fungal disease that causes a white powdery coating on the upper side of tomato leaves. ğŸ…ğŸŒ¨ï¸",
        "cause_en": "Caused by the fungus Leveillula taurica. ğŸ„",
        "treatment_en": "Use fungicides, improve air circulation, and avoid overhead watering. ğŸ’¨ğŸ’§",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ³Ø¨Ø¨ ØªØºØ·ÙŠØ© Ø¨ÙŠØ¶Ø§Ø¡ Ù…Ø³Ø­ÙˆÙ‚ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø¹Ù„ÙˆÙŠ Ù…Ù† Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø·Ù…Ø§Ø·Ù…. ğŸ…ğŸŒ¨ï¸",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Leveillula taurica. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ©ØŒ ÙˆØ­Ø³Ù† Ø§Ù„ØªÙ‡ÙˆÙŠØ©ØŒ ÙˆØªØ¬Ù†Ø¨ Ø§Ù„Ø±ÙŠ Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰. ğŸ’¨ğŸ’§"
    },
    "Tomato___Bacterial_spot": {
        "name_ar": "Ø§Ù„Ø¨Ù‚Ø¹Ø© Ø§Ù„Ø¨ÙƒØªÙŠØ±ÙŠØ©",
        "description_en": "A bacterial disease that causes small, dark lesions on tomato leaves, stems, and fruit. ğŸ…ğŸ¦ ",
        "cause_en": "Caused by Xanthomonas spp. ğŸ¦ ",
        "treatment_en": "Use copper-based fungicides and remove infected plant parts. âŒğŸŒ±",
        "description_ar": "Ù…Ø±Ø¶ Ø¨ÙƒØªÙŠØ±ÙŠ ÙŠØ³Ø¨Ø¨ ØªÙ‚Ø±Ø­Ø§Øª ØµØºÙŠØ±Ø© Ø¯Ø§ÙƒÙ†Ø© Ø¹Ù„Ù‰ Ø£ÙˆØ±Ø§Ù‚ ÙˆØ³ÙŠÙ‚Ø§Ù† ÙˆÙÙˆØ§ÙƒÙ‡ Ø§Ù„Ø·Ù…Ø§Ø·Ù…. ğŸ…ğŸ¦ ",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø¨ÙƒØªÙŠØ±ÙŠØ§ Xanthomonas spp. ğŸ¦ ",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ© Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø­Ø§Ø³ ÙˆØ£Ø²Ù„ Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù†Ø¨Ø§Øª Ø§Ù„Ù…ØµØ§Ø¨Ø©. âŒğŸŒ±"
    },
    "Tomato___Early_blight": {
        "name_ar": "Ø§Ù„Ù„ÙØ­Ø© Ø§Ù„Ù…Ø¨ÙƒØ±Ø©",
        "description_en": "A fungal disease that causes dark, concentric rings on leaves and stems. ğŸ…ğŸ¦ ",
        "cause_en": "Caused by the fungus Alternaria solani. ğŸ„",
        "treatment_en": "Use fungicides, remove infected leaves, and practice crop rotation. ğŸ”„ğŸŒ¿",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ³Ø¨Ø¨ Ø¯ÙˆØ§Ø¦Ø± Ø¯Ø§ÙƒÙ†Ø© Ø¹Ù„Ù‰ Ø£ÙˆØ±Ø§Ù‚ ÙˆØ³ÙŠÙ‚Ø§Ù† Ø§Ù„Ø·Ù…Ø§Ø·Ù…. ğŸ…ğŸ¦ ",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Alternaria solani. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ©ØŒ ÙˆØ£Ø²Ù„ Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ù…ØµØ§Ø¨Ø©ØŒ ÙˆØ§ØªØ¨Ø§Ø¹ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø­Ø§ØµÙŠÙ„. ğŸ”„ğŸŒ¿"
    },
    "Tomato___healthy": {
        "name_ar": "Ù†Ø¨Ø§Øª ØµØ­ÙŠ",
        "description_en": "The plant is healthy with no visible signs of disease. ğŸ…ğŸ˜Š",
        "cause_en": "N/A",
        "treatment_en": "Maintain proper care with regular watering and sunlight. ğŸ’§ğŸŒ",
        "description_ar": "Ø§Ù„Ù†Ø¨Ø§Øª ØµØ­ÙŠ ÙˆÙ„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù„Ø§Ù…Ø§Øª Ø¹Ù„Ù‰ ÙˆØ¬ÙˆØ¯ Ù…Ø±Ø¶. ğŸ…ğŸ˜Š",
        "cause_ar": "Ù„Ø§ ÙŠÙˆØ¬Ø¯",
        "treatment_ar": "Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†Ø§ÙŠØ© Ø§Ù„Ø³Ù„ÙŠÙ…Ø© Ù…Ø¹ Ø§Ù„Ø±ÙŠ Ø§Ù„Ù…Ù†ØªØ¸Ù… ÙˆØ£Ø´Ø¹Ø© Ø§Ù„Ø´Ù…Ø³. ğŸ’§ğŸŒ"
    },
    "Tomato___Late_blight": {
        "name_ar": "Ø§Ù„Ù„ÙØ­Ø© Ø§Ù„Ù…ØªØ£Ø®Ø±Ø©",
        "description_en": "A fungal disease that causes dark, water-soaked lesions on leaves and stems. ğŸ…ğŸŒ§ï¸",
        "cause_en": "Caused by the fungus Phytophthora infestans. ğŸ„",
        "treatment_en": "Use fungicides and remove infected plant parts. Ensure proper spacing to reduce humidity. âŒğŸ’§",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ³Ø¨Ø¨ ØªÙ‚Ø±Ø­Ø§Øª Ø¯Ø§ÙƒÙ†Ø© ÙˆÙ…Ø´Ø¨Ø¹Ø© Ø¨Ø§Ù„Ù…Ø§Ø¡ Ø¹Ù„Ù‰ Ø£ÙˆØ±Ø§Ù‚ ÙˆØ³ÙŠÙ‚Ø§Ù† Ø§Ù„Ø·Ù…Ø§Ø·Ù…. ğŸ…ğŸŒ§ï¸",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Phytophthora infestans. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ© ÙˆØ£Ø²Ù„ Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù†Ø¨Ø§Øª Ø§Ù„Ù…ØµØ§Ø¨Ø©. ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ØªØ¨Ø§Ø¹Ø¯ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø±Ø·ÙˆØ¨Ø©. âŒğŸ’§"
    },
    "Tomato___Leaf_Mold": {
        "name_ar": "Ø¹ÙÙ† Ø§Ù„Ø£ÙˆØ±Ø§Ù‚",
        "description_en": "A fungal disease that causes yellowing and mold growth on the undersides of tomato leaves. ğŸ…ğŸ‚",
        "cause_en": "Caused by the fungus Passalora fulva. ğŸ„",
        "treatment_en": "Apply fungicides and remove affected leaves. ğŸ’¨ğŸŒ¿",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ³Ø¨Ø¨ Ø§ØµÙØ±Ø§Ø± ÙˆÙ†Ù…Ùˆ Ø§Ù„Ø¹ÙÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù†Ø¨ Ø§Ù„Ø³ÙÙ„ÙŠØ© Ù„Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø·Ù…Ø§Ø·Ù…. ğŸ…ğŸ‚",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Passalora fulva. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ© ÙˆØ£Ø²Ù„ Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ù…ØµØ§Ø¨Ø©. ğŸ’¨ğŸŒ¿"
    },
    "Tomato___Septoria_leaf_spot": {
        "name_ar": "Ø¨Ù‚Ø¹Ø© Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø³Ø¨ØªÙŠÙˆØ±ÙŠØ©",
        "description_en": "A fungal disease that causes dark spots with a yellow halo on tomato leaves. ğŸ…ğŸŒ‘",
        "cause_en": "Caused by the fungus Septoria lycopersici. ğŸ„",
        "treatment_en": "Use fungicides and remove affected leaves. âŒğŸƒ",
        "description_ar": "Ù…Ø±Ø¶ ÙØ·Ø±ÙŠ ÙŠØ³Ø¨Ø¨ Ø¨Ù‚Ø¹ Ø¯Ø§ÙƒÙ†Ø© Ù…Ø¹ Ù‡Ø§Ù„Ø© ØµÙØ±Ø§Ø¡ Ø¹Ù„Ù‰ Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø·Ù…Ø§Ø·Ù…. ğŸ…ğŸŒ‘",
        "cause_ar": "ØªØ³Ø¨Ø¨Ù‡ Ø§Ù„ÙØ·Ø±ÙŠØ§Øª Septoria lycopersici. ğŸ„",
        "treatment_ar": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ© ÙˆØ£Ø²Ù„ Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ù…ØµØ§Ø¨Ø©. âŒğŸƒ"
    }
}

disease_causes = {
    # Lettuce Diseases
    "Bacterial": {
        "causes": ["High air humidity", "Poor air circulation", "High soil humidity"],
        "sensor_keys": {
            "air_humidity": "high",
            "rs_hum": "high"
        }
    },
    "Downy_mildew_on_lettuce": {
        "causes": ["High air humidity", "Dark lighting", "Low soil temperature"],
        "sensor_keys": {
            "air_humidity": "high",
            "ldr_d": "low",
            "rs_temp": "low"
        }
    },
    "Lettuce Mosaic Virus": {
        "causes": ["Infected soil pH", "Poor soil conductivity"],
        "sensor_keys": {
            "rs_ph": "high",
            "rs_cond": "low"
        }
    },
    "Powdery_mildew_on_lettuce": {
        "causes": ["High air humidity", "Low light"],
        "sensor_keys": {
            "air_humidity": "high",
            "ldr_d": "low"
        }
    },
    "Septoria_Blight_on_lettuce": {
        "causes": ["High air humidity", "Low soil pH", "Dark lighting"],
        "sensor_keys": {
            "air_humidity": "high",
            "rs_ph": "low",
            "ldr_d": "low"
        }
    },
    "Wilt and leaf blight on lettuce": {
        "causes": ["Low soil humidity", "High air temperature", "Low soil conductivity"],
        "sensor_keys": {
            "rs_hum": "low",
            "temperature": "high",
            "rs_cond": "low"
        }
    },

    # Cucumber Diseases
    "Anthracnose": {
        "causes": ["High air humidity", "High air temperature", "Low soil pH"],
        "sensor_keys": {
            "air_humidity": "high",
            "temperature": "high",
            "rs_ph": "low"
        }
    },
    "Bacterial Wilt": {
        "causes": ["High air temperature", "Low soil humidity"],
        "sensor_keys": {
            "temperature": "high",
            "rs_hum": "low"
        }
    },
    "Downy Mildew": {
        "causes": ["High air humidity", "Dark lighting", "Low soil temperature"],
        "sensor_keys": {
            "air_humidity": "high",
            "ldr_d": "low",
            "rs_temp": "low"
        }
    },
    "Fresh Leaf": {
        "causes": [],
        "sensor_keys": {}
    },
    "Gummy Stem Blight": {
        "causes": ["High soil humidity", "Low soil pH"],
        "sensor_keys": {
            "rs_hum": "high",
            "rs_ph": "low"
        }
    },
    "Powdery Mildew": {
        "causes": ["High air humidity", "Low light", "Poor air circulation"],
        "sensor_keys": {
            "air_humidity": "high",
            "ldr_d": "low"
        }
    },

    # Tomato Diseases
    "Gray spot": {
        "causes": ["High air humidity", "Dark light conditions", "Low soil EC"],
        "sensor_keys": {
            "air_humidity": "high",
            "ldr_d": "low",
            "rs_cond": "low"
        }
    },
    "powdery mildew": {
        "causes": ["High air humidity", "Low light", "Poor air movement"],
        "sensor_keys": {
            "air_humidity": "high",
            "ldr_d": "low"
        }
    },
    "Tomato___Bacterial_spot": {
        "causes": ["High air humidity", "Low soil pH"],
        "sensor_keys": {
            "air_humidity": "high",
            "rs_ph": "low"
        }
    },
    "Tomato___Early_blight": {
        "causes": ["High soil humidity", "High temperature", "Low soil EC"],
        "sensor_keys": {
            "rs_hum": "high",
            "temperature": "high",
            "rs_cond": "low"
        }
    },
    "Tomato___healthy": {
        "causes": [],
        "sensor_keys": {}
    },
    "Tomato___Late_blight": {
        "causes": ["High air humidity", "Low soil temperature", "Poor lighting"],
        "sensor_keys": {
            "air_humidity": "high",
            "rs_temp": "low",
            "ldr_d": "low"
        }
    },
    "Tomato___Leaf_Mold": {
        "causes": ["High air humidity", "Dark light", "High soil humidity"],
        "sensor_keys": {
            "air_humidity": "high",
            "ldr_d": "low",
            "rs_hum": "high"
        }
    },
    "Tomato___Septoria_leaf_spot": {
        "causes": ["High air humidity", "Low soil pH"],
        "sensor_keys": {
            "air_humidity": "high",
            "rs_ph": "low"
        }
    }
}



#------------------------------LANGUAGE-------------------------------------------------

@bot.callback_query_handler(func=lambda call: call.data in ["/language", "/tips", "/ChoosePlant", "/sensors"])
def simulate_command(call):
    chat_id = call.message.chat.id

    if call.data == "/language":
        # Simulate /language command
        choose_language(call.message)

    elif call.data == "/tips":
        # Simulate /tips command
        handle_tips(call.message)

    elif call.data == "/ChoosePlant":
        # Simulate /ChoosePlant command
        handle_capture(call.message)  # Make sure you have a command handler named choose_plant

    elif call.data == "/sensors":
        handle_sensors(call.message)  # Your existing /sensors command handler

    bot.answer_callback_query(call.id)  # Avoid "loading" spinner



@bot.message_handler(commands=['language'])
def choose_language(message):
    chat_id = message.chat.id
    markup = InlineKeyboardMarkup()
    markup.row(
        InlineKeyboardButton(" English", callback_data='lang_en'),
        InlineKeyboardButton(" Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data='lang_ar')
    )
    bot.send_message(chat_id, "ğŸŒ Please choose your language:\nÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù„ØºØªÙƒ:", reply_markup=markup)


@bot.callback_query_handler(func=lambda call: call.data.startswith('lang_'))
def handle_language_choice(call):
    chat_id = call.message.chat.id
    language_code = call.data.split('_')[1]

    user_languages[chat_id] = language_code  # Save user choice

    if language_code == 'en':
        text = "âœ… Language set to *English*.\n\nClick the button below to begin! ğŸŒ±"
        button_text = "ğŸ“Š Start Smart Farming"
    else:
        text = "âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© *Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©*.\n\nØ§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„Ø¨Ø¯Ø¡! ğŸŒ¿"
        button_text = "ğŸ“Š Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø²Ø±Ø§Ø¹Ø© Ø§Ù„Ø°ÙƒÙŠØ©"

    # Create the inline keyboard with a button that triggers /start
    keyboard = types.InlineKeyboardMarkup()
    keyboard.add(types.InlineKeyboardButton(button_text, callback_data='/start'))

    bot.send_message(chat_id, text, reply_markup=keyboard, parse_mode="Markdown")



def get_plant_type_translations(plant_type):
    plant_type_translation = {
        "lettuce": "Ø®Ø³",
        "tomato": "Ø·Ù…Ø§Ø·Ù…",
        "cucumber": "Ø®ÙŠØ§Ø±"

    }
    plant_type_en = plant_type.capitalize()
    plant_type_ar = plant_type_translation.get(plant_type.lower(), plant_type_en)
    return plant_type_en, plant_type_ar

#------------------------------ START -------------------------------------------------
@bot.message_handler(commands=['start'])
def handle_start(message):
    chat_id = message.chat.id
    handle_start_from_callback(chat_id)

# ğŸ‘‰ Callback when user clicks ğŸ“Š Start Smart Farming
@bot.callback_query_handler(func=lambda call: call.data == "/start")
def handle_start_callback(call):
    chat_id = call.message.chat.id
    handle_start_from_callback(chat_id)


# ğŸ‘‰ Shared function for start logic (used by both methods above)
def handle_start_from_callback(chat_id):


    # If user has not selected a language yet
    if chat_id not in user_languages:
        markup = InlineKeyboardMarkup()
        markup.row(
            InlineKeyboardButton(" English", callback_data='lang_en'),
            InlineKeyboardButton(" Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data='lang_ar')
        )
        bot.send_message(
            chat_id,
            "ğŸŒ Please choose your language first:\nÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù„ØºØªÙƒ Ø£ÙˆÙ„Ø§Ù‹:",
            reply_markup=markup
        )
        return

    lang = user_languages.get(chat_id, 'en')

    if lang == 'ar':
        welcome_message = """
ğŸ‘‹ *Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙÙŠ Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„Ø²Ø±Ø§Ø¹Ø© Ø§Ù„Ø°ÙƒÙŠØ©!* ğŸŒ¿

Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª ÙŠØ³Ø§Ø¹Ø¯Ùƒ ÙÙŠ:
âœ… ÙƒØ´Ù Ø£Ù…Ø±Ø§Ø¶ Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ù†Ø¨Ø§ØªØ§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
âœ… Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ´Ø¹Ø±Ø§Øª ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙØ¹Ù„ÙŠ
âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†ØµØ§Ø¦Ø­ Ø®Ø§ØµØ© Ø¨Ø±Ø¹Ø§ÙŠØ© Ù…Ø­Ø§ØµÙŠÙ„Ùƒ

ğŸ”§ *ÙƒÙŠÙ ÙŠØ¹Ù…Ù„:*
1ï¸âƒ£ Ø§Ø³ØªØ®Ø¯Ù… /ChoosePlant Ù„Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø­ØµÙˆÙ„ (Ø·Ù…Ø§Ø·Ù…ØŒ Ø®Ø³ØŒ Ø®ÙŠØ§Ø±).
2ï¸âƒ£ Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© ÙˆØ§Ø¶Ø­Ø© Ù„Ù„ÙˆØ±Ù‚Ø©.
3ï¸âƒ£ Ø³ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ´Ø®ÙŠØµ Ù…Ø¨Ø§Ø´Ø±Ø©.
4ï¸âƒ£ Ø§Ø³ØªØ®Ø¯Ù… /sensors Ù„ØªØ­Ù„ÙŠÙ„ Ù‚Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ù…Ø³ØªØ´Ø¹Ø±Ø§Øª.

ğŸ’¡ *Ù†ØµÙŠØ­Ø©:* Ø¬ÙˆØ¯Ø© Ø§Ù„ØµÙˆØ±Ø© ØªØ¤Ø«Ø± Ø¹Ù„Ù‰ Ø¯Ù‚Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬.
ğŸ“Œ Ø§Ø³ØªØ®Ø¯Ù… /tips Ù„Ù†ØµØ§Ø¦Ø­ Ø§Ù„Ø¹Ù†Ø§ÙŠØ© Ø¨Ø§Ù„Ù…Ø­ØµÙˆÙ„.
ğŸŒ Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© ÙÙŠ Ø£ÙŠ ÙˆÙ‚ØªØŒ Ø§ÙƒØªØ¨ /language

ğŸš€ Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¢Ù† Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ /ChoosePlant!


"""
    else:
        welcome_message = """
ğŸ‘‹ *Welcome to the Smart Farming Plant Assistant!* ğŸŒ¿

This bot helps you:
âœ… Detect plant leaf diseases using AI
âœ… Monitor real-time sensor data (temperature, moisture, pH, etc.)
âœ… Receive tailored care tips for your crops

ğŸ”§ *How It Works:*
1ï¸âƒ£ Use /ChoosePlant to select a crop (tomato, lettuce, or cucumber).
2ï¸âƒ£ Send a clear, well-lit photo of the plantâ€™s leaf.
3ï¸âƒ£ The bot will analyze the image and provide a diagnosis.
4ï¸âƒ£ Use /sensors to fetch and analyze your latest environmental sensor data.

ğŸ’¡ *Tip:* Better image quality = more accurate results.
ğŸ“Œ Use /tips for crop-specific care recommendations.
ğŸŒ To change your language at any time, Click on /language

ğŸš€ Get started now by Click on /ChoosePlant!


"""
    bot.send_message(chat_id, welcome_message, parse_mode="Markdown")



#----------------------CHOOSE PLANT-----------------------------------------------

@bot.message_handler(commands=['ChoosePlant'])
def handle_capture(message):
    chat_id = message.chat.id
    lang = user_languages.get(chat_id, "en")

    if lang == "ar":
        text = "ğŸŒ± *Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ù†Ø¨Ø§Øª Ø§Ù„Ø°ÙŠ ØªØ±ØºØ¨ ÙÙŠ ØªØ­Ù„ÙŠÙ„Ù‡:*"
    else:
        text = "ğŸŒ± *Please select the plant you want to analyze:*"

    bot.send_message(chat_id, text, reply_markup=plant_selection_markup(chat_id), parse_mode="Markdown")



def plant_selection_markup(chat_id):
    lang = user_languages.get(chat_id, 'en')
    markup = InlineKeyboardMarkup()

    if lang == 'ar':
        markup.add(InlineKeyboardButton("  Ø®Ø³ ğŸ¥¬", callback_data="Lettuce"))
        markup.add(InlineKeyboardButton(" Ø®ÙŠØ§Ø± ğŸ¥’", callback_data="Cucumber"))
        markup.add(InlineKeyboardButton(" Ø·Ù…Ø§Ø·Ù… ğŸ…", callback_data="Tomato"))
    else:
        markup.add(InlineKeyboardButton("Lettuce ğŸ¥¬", callback_data="Lettuce"))
        markup.add(InlineKeyboardButton("Cucumber ğŸ¥’", callback_data="Cucumber"))
        markup.add(InlineKeyboardButton("Tomato ğŸ…", callback_data="Tomato"))

    return markup


@bot.callback_query_handler(func=lambda call: call.data in ["Lettuce", "Cucumber", "Tomato"])
def handle_plant_selection(call):
    chat_id = call.message.chat.id
    user_choices[chat_id] = call.data

    lang = user_languages.get(chat_id, 'en')  # Get the user's language (default to English)

    # Get translated plant names for display
    plant_type_en, plant_type_ar = get_plant_type_translations(call.data.lower())

    if lang == "ar":
        bot.send_message(chat_id, f"ğŸ”¹ Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª: {plant_type_ar} . Ø§Ù„Ø¢Ù†ØŒ Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© ÙˆØ§Ø¶Ø­Ø© Ù„Ù„ÙˆØ±Ù‚Ø© Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø£Ùˆ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ /sensors Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚ÙŠÙ… Ø§Ù„Ø­Ø³Ø§Ø³Ø§Øª Ù„Ù‡Ø°Ø§ Ø§Ù„Ù…Ø­ØµÙˆÙ„.")
    else:
        bot.send_message(chat_id, f"ğŸ”¹ You selected: {plant_type_en}. Now, send a clear leaf image for analysis or Click on /sensors to get the sensor values for this plant.")

#------------------------------SENSORS NORMAL RANGE -------------------------------------------------


# Place utility function for range checking at the top of your code
def check_sensor_range(value, min_val, max_val):
    return min_val <= value <= max_val



# Conversion from mS/cm to dS/m
def convert_ec_to_ds(value_ms_cm):
    return value_ms_cm / 10  # Conversion factor from mS/cm to dS/m

# Function to fetch crop-specific data
def get_crop_info(crop_name):
    crop_data = {
        "tomato": {
            "growth_period": "90â€“150 days",
            "ranges": {
                "Air Temperature (Â°C)": (18, 27),
                "Air Humidity (%)": (60, 70),
                "Soil pH": (6.2, 6.8),
                "Soil EC (dS/m)": (2.5, 3.5),
                "Light (LDR Analog)": (200, 800),
                "Soil Temperature (Â°C)": (18, 27),

                "Soil Humidity (%)": (60, 70),
            }
        },
        "lettuce": {
            "growth_period": "45â€“70 days",
            "ranges": {
                "Air Temperature (Â°C)": (15, 20),
                "Air Humidity (%)": (50, 70),
                "Soil pH": (6.0, 6.5),
                "Soil EC (dS/m)": (0.8, 3.5),
                "Light (LDR Analog)": (200, 800),
                "Soil Temperature (Â°C)": (15, 18),

                "Soil Humidity (%)": (60, 80),
            }
        },
        "cucumber": {
            "growth_period": "50â€“70 days",
            "ranges": {
                "Air Temperature (Â°C)": (24, 30),
                "Air Humidity (%)": (60, 80),
                "Soil pH": (6, 7.5),
                "Soil EC (dS/m)": (1.7, 2.5),
                "Light (LDR Analog)": (200, 800),
                "Soil Temperature (Â°C)": (18, 24),

                "Soil Humidity (%)": (60, 70),
            }
        }
    }
    return crop_data.get(crop_name.lower())

#-------------------------- SENSOR FEEDBACK ----------------------------------------------------

def get_sensor_feedback(sensor_values, crop_name, language="en"):
    crop_info = get_crop_info(crop_name)
    feedback_lines = []

    if crop_info is None:
        return (
            "âš ï¸ Unknown crop selected." if language == "en" else "âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­ØµÙˆÙ„."
        )

    optimal_ranges = crop_info["ranges"]
    out_of_range_count = 0

    # Sensor name translations for Arabic
    sensor_translations = {
        "Air Temperature (Â°C)": "Ø¯Ø±Ø¬Ø© Ø­Ø±Ø§Ø±Ø© Ø§Ù„Ù‡ÙˆØ§Ø¡ (Ø³Â°)",
        "Air Humidity (%)": "Ø±Ø·ÙˆØ¨Ø© Ø§Ù„Ù‡ÙˆØ§Ø¡ (%)",

        "Light (LDR Analog)": "Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¶ÙˆØ¡ ",
        "Light (LDR Digital)": "Ø´Ø¯Ø© Ø§Ù„Ø¶ÙˆØ¡ ",
        "Soil Temperature (Â°C)": "Ø¯Ø±Ø¬Ø© Ø­Ø±Ø§Ø±Ø© Ø§Ù„ØªØ±Ø¨Ø© (Ø³Â°)",
        "Soil Humidity (%)": "Ø±Ø·ÙˆØ¨Ø© Ø§Ù„ØªØ±Ø¨Ø© (%)",
        "Soil EC (dS/m)": "Ø§Ù„ØªÙˆØµÙŠÙ„ÙŠØ© Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ© (EC)",
        "Soil pH": "Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ù…ÙˆØ¶Ø© (pH)"
    }

    # Feedback emojis
    good_emoji = "âœ…"
    warn_emoji = "âš ï¸"
    up_arrow = "ğŸ”º"
    down_arrow = "ğŸ”»"

    for key, (min_val, max_val) in optimal_ranges.items():
        value = sensor_values.get(key)

        # Convert EC units if needed
        if key == "Soil EC (dS/m)":
            value = convert_ec_to_ds(value)

        # Only process numeric values
        try:
            numeric_value = float(value)
        except:
            continue

        in_range = check_sensor_range(numeric_value, min_val, max_val)

        if not in_range:
            out_of_range_count += 1
            direction = up_arrow if numeric_value > max_val else down_arrow

            # Use correct language key name
            display_key = sensor_translations.get(key, key) if language == "ar" else key

            # Calculate adjustment
            if numeric_value > max_val:
                adjustment_amount = numeric_value - max_val
                adjustment = (
                    f"Try decreasing the {display_key} by {adjustment_amount:.2f}Â°C to be within the optimal range.\n"
                    if language == "en"
                    else f"Ø­Ø§ÙˆÙ„ ØªÙ‚Ù„ÙŠÙ„ {display_key} Ø¨Ù…Ù‚Ø¯Ø§Ø± {adjustment_amount:.2f} Ø³Â° Ù„ÙŠÙƒÙˆÙ† Ø¶Ù…Ù† Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ù…Ø«Ø§Ù„ÙŠ.\n"
                )
            elif numeric_value < min_val:
                adjustment_amount = min_val - numeric_value
                adjustment = (
                    f"Try increasing the {display_key} by {adjustment_amount:.2f}Â°C to be within the optimal range.\n"
                    if language == "en"
                    else f"Ø­Ø§ÙˆÙ„ Ø²ÙŠØ§Ø¯Ø© {display_key} Ø¨Ù…Ù‚Ø¯Ø§Ø± {adjustment_amount:.2f}Ø³Â° Ù„ÙŠÙƒÙˆÙ† Ø¶Ù…Ù† Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ù…Ø«Ø§Ù„ÙŠ.\n"
                )

            feedback_lines.append(
                f"{warn_emoji} *{display_key}* is out of range ({min_val}â€“{max_val}). Current: {numeric_value} {direction}. {adjustment}\n"
                if language == "en"
                else f"{warn_emoji} *{display_key}* Ø®Ø§Ø±Ø¬ Ø§Ù„Ù†Ø·Ø§Ù‚ ({min_val}â€“{max_val}). Ø§Ù„Ø­Ø§Ù„ÙŠ: {numeric_value} {direction}. {adjustment}\n"
            )
        else:
            display_key = sensor_translations.get(key, key) if language == "ar" else key
            feedback_lines.append(
                f"{good_emoji} *{display_key}* is within optimal range.\n"
                if language == "en"
                else f"{good_emoji} *{display_key}* Ø¶Ù…Ù† Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ù…Ø«Ø§Ù„ÙŠ.\n"
            )

    # Summary at the top
    total = len(optimal_ranges)
    if language == "ar":
        summary = (
            f"{warn_emoji} {out_of_range_count} Ù…Ù† Ø£ØµÙ„ {total} Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø³Ø§Øª Ø®Ø§Ø±Ø¬ Ø§Ù„Ù†Ø·Ø§Ù‚.\n\n"
            if out_of_range_count > 0
            else f"{good_emoji} Ø¬Ù…ÙŠØ¹ Ù‚Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø§Øª Ø¶Ù…Ù† Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ù…Ø«Ø§Ù„ÙŠ Ù„Ù…Ø­ØµÙˆÙ„ {crop_name.lower()}.\n\n"
        )
    elif language == "en":
        summary = (
            f"{warn_emoji} {out_of_range_count} out of {total} sensors are out of range.\n\n"
            if out_of_range_count > 0
            else f"{good_emoji} All sensor readings are within optimal ranges for {crop_name.lower()}.\n\n"
        )
    else:
        summary = (
            f"{warn_emoji} {out_of_range_count}/{total} sensors are not in range.\n\n"
            if out_of_range_count > 0
            else f"{good_emoji} All sensors are in healthy range for {crop_name.lower()}.\n\n"
        )

    return summary + "\n".join(feedback_lines)



#----------------------- ADVICE ----------------------




def generate_disease_sensor_advice(disease_name, sensor_values, crop_name, language="en"):
    crop_info = get_crop_info(crop_name)
    if not crop_info:
        return ""

    optimal_ranges = crop_info["ranges"]
    disease_info = disease_causes.get(disease_name)
    if not disease_info:
        return ""

    sensor_keys = disease_info.get("sensor_keys", {})
    sensor_feedback = []

    # Map internal sensor keys to readable names
    sensor_label_map_en = {
        "temperature": "Air Temperature (Â°C)",
        "air_humidity": "Air Humidity (%)",
        "rs_ph": "Soil pH",
        "rs_cond": "Soil EC (dS/m)",
        "ldr_d": "Light (LDR Analog)",
        "rs_temp": "Soil Temperature (Â°C)",
        "rs_hum": "Soil Humidity (%)"
    }


    sensor_label_map_ar = {
        "temperature": "Ø¯Ø±Ø¬Ø© Ø­Ø±Ø§Ø±Ø© Ø§Ù„Ù‡ÙˆØ§Ø¡ (Â°C)",
        "air_humidity": "Ø±Ø·ÙˆØ¨Ø© Ø§Ù„Ù‡ÙˆØ§Ø¡ (%)",
        "rs_ph": "Ø¯Ø±Ø¬Ø© Ø­Ù…ÙˆØ¶Ø© Ø§Ù„ØªØ±Ø¨Ø©",
        "rs_cond": "ØªÙˆØµÙŠÙ„ Ø§Ù„ØªØ±Ø¨Ø© Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠ (dS/m)",
        "ldr_d": "Ø§Ù„Ø¶ÙˆØ¡ (LDR)",
        "rs_temp": "Ø¯Ø±Ø¬Ø© Ø­Ø±Ø§Ø±Ø© Ø§Ù„ØªØ±Ø¨Ø© (Â°C)",
        "rs_hum": "Ø±Ø·ÙˆØ¨Ø© Ø§Ù„ØªØ±Ø¨Ø© (%)"
    }

# Choose correct label map based on language
    sensor_label_map = sensor_label_map_ar if language == "ar" else sensor_label_map_en


    cause_phrases_en = {
        "low": "Too low â€” consider increasing it.",
        "high": "Too high â€” consider decreasing it."
    }

    cause_phrases_ar = {
        "low": "Ù…Ù†Ø®ÙØ¶ Ø¬Ø¯Ù‹Ø§ â€” ÙŠÙÙØ¶Ù„ Ø²ÙŠØ§Ø¯ØªÙ‡.",
        "high": "Ù…Ø±ØªÙØ¹ Ø¬Ø¯Ù‹Ø§ â€” ÙŠÙÙØ¶Ù„ ØªÙ‚Ù„ÙŠÙ„Ù‡."
    }

    for key, expected_direction in sensor_keys.items():
        readable_key = sensor_label_map.get(key)
        english_key = sensor_label_map_en.get(key)
        if not readable_key:
            continue

        sensor_val = sensor_values.get(sensor_label_map_en.get(key))  # Always use EN keys to get sensor value

        if key == "rs_cond":
            sensor_val = convert_ec_to_ds(sensor_val)

        try:
            value = float(sensor_val)
        except:
            continue

        min_val, max_val = optimal_ranges.get(english_key, (None, None))
        if min_val is None or max_val is None:
            continue

        if value < min_val:
            direction = "low"
        elif value > max_val:
            direction = "high"
        else:
            continue  # In range

        if direction != expected_direction:
            continue  # Skip this sensor â€” not matching disease cause

        phrase = cause_phrases_ar[direction] if language == "ar" else cause_phrases_en[direction]
        if language == "ar":
            sensor_feedback.append(f"â¤ *{readable_key} ({sensor_label_map_en.get(key)})* Ø®Ø§Ø±Ø¬ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ù…Ø«Ø§Ù„ÙŠ. {phrase}")
        else:
            sensor_feedback.append(f"â¤ *{readable_key}* is out of optimal range. {phrase}")

    if sensor_feedback:
        header = "\n\nğŸŒ¿ *Possible sensor-related causes for this disease:*\n" if language == "en" else "\n\nğŸŒ¿ *Ø§Ù„Ø£Ø³Ø¨Ø§Ø¨ Ø§Ù„Ù…Ø­ØªÙ…Ù„Ø© Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø­Ø³Ø§Ø³Ø§Øª Ù„Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¶:*\n"
        return header + "\n".join(sensor_feedback)
    else:
        no_advice_msg = (
            "\n\nâœ… Based on current sensor readings, no environmental factors related to this disease have been detected."
            if language == "en"
            else "\n\nâœ… Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù‚Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©ØŒ Ù„Ù… ÙŠØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø£ÙŠ Ø¹ÙˆØ§Ù…Ù„ Ø¨ÙŠØ¦ÙŠØ© Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¶."
        )
        return no_advice_msg

#----------------------Sensors---------------------------------------------------------------------------------

def format_sensor_message(plant_type, sensor_data, feedback, lang="en"):
    # Check the LDR digital value and set the display text
    ldr_digital_status = "Bright" if sensor_data['Light (LDR Digital)'] == 0 else "Dark"

    if lang == "ar":
        return (
            f"*ğŸ“¥ ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³ Ù„Ù…Ø­ØµÙˆÙ„ {plant_type}:*\n"
            f"- ğŸŒ¡ï¸ Ø¯Ø±Ø¬Ø© Ø­Ø±Ø§Ø±Ø© Ø§Ù„Ù‡ÙˆØ§Ø¡: {sensor_data['Air Temperature (Â°C)']} Â°Ø³\n"
            f"- ğŸ’§ Ø±Ø·ÙˆØ¨Ø© Ø§Ù„Ù‡ÙˆØ§Ø¡: {sensor_data['Air Humidity (%)']} %\n"

            f"- ğŸ’¡ Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¶ÙˆØ¡ : {sensor_data['Light (LDR Analog)']}\n"
            f"- ğŸ’¡ Ø´Ø¯Ø© Ø§Ù„Ø¶ÙˆØ¡ : {ldr_digital_status}\n\n"

            f"- ğŸŒ¡ï¸ Ø¯Ø±Ø¬Ø© Ø­Ø±Ø§Ø±Ø© Ø§Ù„ØªØ±Ø¨Ø©: {sensor_data['Soil Temperature (Â°C)']} Â°Ø³\n"
            f"- ğŸ’§ Ø±Ø·ÙˆØ¨Ø© Ø§Ù„ØªØ±Ø¨Ø©: {sensor_data['Soil Humidity (%)']} %\n"
            f"- âš¡ Ø§Ù„ØªÙˆØµÙŠÙ„ÙŠØ© Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ© (EC): {sensor_data['Soil EC (dS/m)']} dS/m\n"
            f"- ğŸ§ª Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ù…ÙˆØ¶Ø© (pH): {sensor_data['Soil pH']}\n\n"
            f"*ğŸŒ± Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªØ­Ù„ÙŠÙ„:*\n{feedback}"
        )
    else:
        return (
            f"*ğŸ“¥ Sensor Data Received for {plant_type}:*\n"
            f"- ğŸŒ¡ï¸ Air Temperature: {sensor_data['Air Temperature (Â°C)']} Â°C\n"
            f"- ğŸ’§ Air Humidity: {sensor_data['Air Humidity (%)']} %\n"

            f"- ğŸ’¡ Light (Analog): {sensor_data['Light (LDR Analog)']}\n"
            f"- ğŸ’¡ Light (Digital): {ldr_digital_status}\n\n"

            f"- ğŸŒ¡ï¸ Soil Temperature: {sensor_data['Soil Temperature (Â°C)']} Â°C\n"
            f"- ğŸ’§ Soil Humidity: {sensor_data['Soil Humidity (%)']} %\n"
            f"- âš¡ Conductivity (EC): {sensor_data['Soil EC (dS/m)']} dS/m\n"
            f"- ğŸ§ª pH Level: {sensor_data['Soil pH']}\n\n"
            f"*ğŸŒ± Sensor Feedback:*\n{feedback}"
        )


# Main /sensors command handler
@bot.message_handler(commands=['sensors'])
def handle_sensors(message):
    chat_id = message.chat.id
    lang = user_languages.get(chat_id, 'en')

    # ğŸ”’ Check if the user has selected a plant
    if chat_id not in user_choices:
        if lang == "ar":
            bot.reply_to(message, "âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ù†Ø¨Ø§Øª Ø£ÙˆÙ„Ø§Ù‹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… /ChoosePlant Ù‚Ø¨Ù„ Ø§Ø³ØªØ®Ø¯Ø§Ù… /sensors.")
        else:
            bot.reply_to(message, "âš ï¸ Please select a plant type first using /ChoosePlant before using /sensors.")
        return

    text_after_command = message.text[len("/sensors"):].strip()

    # If no payload is given, fetch from Drive
    if not text_after_command:
        sensor_data = get_sensor_data_from_drive()
        if sensor_data is None:
            if lang == "ar":
                bot.reply_to(message, "âŒ Ù„Ù… ÙŠØªÙ…ÙƒÙ† Ù…Ù† Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³ Ù…Ù† Google Drive.")
            else:
                bot.reply_to(message, "âŒ Could not fetch sensor data from Google Drive.")
            return
    else:
        # If payload is given, parse it as JSON and store
        try:
            sensor_data = json.loads(text_after_command)
            sensor_values[chat_id] = sensor_data
            if lang == "ar":
                bot.reply_to(message, "ğŸ“Š ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³ (JSON) ÙˆØªØ®Ø²ÙŠÙ†Ù‡Ø§ Ø¨Ù†Ø¬Ø§Ø­.")
            else:
                bot.reply_to(message, "ğŸ“Š Sensor data (JSON) received and stored successfully.")
        except Exception as e:
            if lang == "ar":
                bot.reply_to(message, "âŒ ØµÙŠØºØ© JSON ØºÙŠØ± ØµØ­ÙŠØ­Ø©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ù…Ø«Ù„:\n/sensors {\"temperature\":25,\"humidity\":60,...}")
            else:
                bot.reply_to(message, "âŒ Invalid JSON format. Please send valid sensor data like:\n/sensors {\"temperature\":25,\"humidity\":60,...}")
            print(f"Error in /sensors handler: {e}")
            return

    # ğŸŒ± Get the selected plant and immediately remove it to enforce one-time use
    plant_type = user_choices.pop(chat_id)  # â— Remove after use

    # Extract values
    temperature = sensor_data.get('temperature', 'N/A')
    humidity = sensor_data.get('humidity', 'N/A')

    ldr_a = sensor_data.get('ldrAnalog', 'N/A')
    ldr_d = sensor_data.get('ldrDigital', 'N/A')

    # RS485 values
    rs_temp = sensor_data.get('rs485_temperature', 'N/A')
    rs_hum = sensor_data.get('rs485_humidity', 'N/A')
    rs_cond = sensor_data.get('rs485_conductivity', 'N/A')
    rs_ph = sensor_data.get('rs485_ph', 'N/A')

    # Save to global storage
    sensor_values[chat_id] = {
        "Air Temperature (Â°C)": temperature,
        "Air Humidity (%)": humidity,

        "Light (LDR Analog)": ldr_a,
        "Light (LDR Digital)": ldr_d,
        "Soil Temperature (Â°C)": rs_temp,
        "Soil Humidity (%)": rs_hum,
        "Soil EC (dS/m)": rs_cond,
        "Soil pH": rs_ph
    }

    # Prepare sensor feedback comparison
    sensor_for_feedback = {
        "Air Temperature (Â°C)": temperature,
        "Air Humidity (%)": humidity,

        "Light (LDR Analog)": ldr_a,
        "Light (LDR Digital)": ldr_d,
        "Soil Temperature (Â°C)": rs_temp,
        "Soil Humidity (%)": rs_hum,
        "Soil EC (dS/m)": rs_cond,
        "Soil pH": rs_ph
    }

    # Get the feedback result
    sensor_feedback = get_sensor_feedback(sensor_for_feedback, plant_type, lang)

    # Format the message
    message_text = format_sensor_message(plant_type, sensor_for_feedback, sensor_feedback, lang)

    bot.send_message(chat_id, message_text, parse_mode="Markdown")



    keyboard = types.InlineKeyboardMarkup()

    if lang == "ar":
        keyboard.add(types.InlineKeyboardButton("ğŸ” ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø©", callback_data="/ChoosePlant"))
        keyboard.add(types.InlineKeyboardButton("ğŸ’¡ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†ØµØ§Ø¦Ø­", callback_data="/tips"))
        keyboard.add(types.InlineKeyboardButton("ğŸŒ ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ©", callback_data="/language"))
    else:
        keyboard.add(types.InlineKeyboardButton("ğŸ” Analyze Image", callback_data="/ChoosePlant"))
        keyboard.add(types.InlineKeyboardButton("ğŸ’¡ Get Tips", callback_data="/tips"))
        keyboard.add(types.InlineKeyboardButton("ğŸŒ Change My Language", callback_data="/language"))


    if lang == "ar":
                message = "ğŸ”„ Ù…Ø§Ø°Ø§ ØªØ±ØºØ¨ ÙÙŠ Ø§Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡ Ø¨Ø¹Ø¯ Ø°Ù„ÙƒØŸ"
    else:
                message = "ğŸ”„ What would you like to do next?"

    bot.send_message(chat_id, message, reply_markup=keyboard)



#---------------------- IMAGE ANALYSIS ---------------------------------------------------------------------------------------


def format_disease_name(name):
    # Replace underscores with spaces and capitalize each word
    return ' '.join(word.capitalize() for word in name.replace('_', ' ').split())

def translate_growth_stage(growth_stage, lang):
    if lang == "ar":
        return growth_stage.replace("days", "Ø£ÙŠØ§Ù…")
    return growth_stage



@bot.message_handler(content_types=['photo'])
def handle_image(message):
    chat_id = message.chat.id
    lang = user_languages.get(chat_id, 'en')



    if chat_id not in user_choices:
        bot.reply_to(message, "âŒ Please select a plant type first using /ChoosePlant.")
        return

    if not message.photo:
        msg = "âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© ØµØ§Ù„Ø­Ø©." if lang == "ar" else "âŒ Please send a valid image."
        bot.reply_to(message, msg)
        return


    plant_type = user_choices[chat_id]


    plant_type_en, plant_type_ar = get_plant_type_translations(plant_type)




    model_info = models.get(plant_type)
    model = YOLO(model_info["path"])
    class_names = model_info["classes"]

    # Download and save the image
    file_id = message.photo[-1].file_id
    file_info = bot.get_file(file_id)
    file_url = f"https://api.telegram.org/file/bot{BOT_TOKEN}/{file_info.file_path}"
    img_path = f"/content/drive/My Drive/Telegram_Images/{plant_type}_image.jpg"
    with open(img_path, "wb") as f:
        f.write(requests.get(file_url).content)


    bot.send_message(chat_id, "ğŸ•µï¸â€â™‚ï¸ Ø¬Ø§Ø±Ù ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±..." if lang == "ar" else "ğŸ•µï¸â€â™‚ï¸ Analyzing the image, please wait...")


    try:
        results = model(img_path)
        pred_boxes = results[0].boxes

        if len(pred_boxes) > 0:
            pred_label = int(pred_boxes.cls[0].item())
            confidence = float(pred_boxes.conf[0].item()) * 100
            #predicted_disease = class_names[pred_label]

            raw_disease = class_names[pred_label]
            predicted_disease = raw_disease  # Keep raw for dictionary lookup

            info = disease_info.get(predicted_disease, {})
            pretty_disease_name_en = format_disease_name(predicted_disease)
            pretty_disease_name_ar = info.get("name_ar", pretty_disease_name_en)



            if lang == "ar":
                if confidence > 85:
                    confidence_msg = "ğŸ” Ø§ÙƒØªØ´Ø§Ù Ø¨Ø¯Ø±Ø¬Ø© Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©"
                elif confidence > 60:
                    confidence_msg = "â„¹ï¸ Ø§ÙƒØªØ´Ø§Ù Ø¨Ø¯Ø±Ø¬Ø© Ø«Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø©"
                else:
                    confidence_msg = "âš ï¸ Ø§ÙƒØªØ´Ø§Ù Ù…Ù†Ø®ÙØ¶ Ø§Ù„Ø«Ù‚Ø©. ÙŠØ±Ø¬Ù‰ ØªØ¬Ø±Ø¨Ø© ØµÙˆØ±Ø© Ø£Ø®Ø±Ù‰ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¯Ù‚Ø© Ø£ÙØ¶Ù„"
            else:
                if confidence > 85:
                    confidence_msg = "ğŸ” High confidence detection."
                elif confidence > 60:
                    confidence_msg = "â„¹ï¸ Moderate confidence."
                else:
                    confidence_msg = "âš ï¸ Low confidence. Please try another image for better accuracy."



            # Fetch the latest sensor data from Google Drive
            sensor_data = get_sensor_data_from_drive()


            if sensor_data is None:
                msg = "âŒ Ù„Ù… ÙŠØªÙ…ÙƒÙ† Ù…Ù† Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹." if lang == "ar" else "âŒ Could not fetch sensor data. Please try again later."
                bot.send_message(chat_id, msg)
                return

            # Get sensor feedback (Check sensor ranges)
            # Convert raw sensor keys into readable format for range checking
            sensor_for_feedback = {
                "Air Temperature (Â°C)": sensor_data.get("temperature"),
                "Air Humidity (%)": sensor_data.get("humidity"),

                "Light (LDR Analog)": sensor_data.get("ldrAnalog"),
                "Soil Temperature (Â°C)": sensor_data.get("rs485_temperature"),
                "Soil Humidity (%)": sensor_data.get("rs485_humidity"),
                "Soil EC (dS/m)": sensor_data.get("rs485_conductivity"),
                "Soil pH": sensor_data.get("rs485_ph")
            }

            # Now get feedback with the correctly formatted keys
            sensor_feedback = get_sensor_feedback(sensor_for_feedback, plant_type, lang)
            advice = generate_disease_sensor_advice(predicted_disease, sensor_for_feedback, plant_type, lang)
            disease = disease_info.get(predicted_disease, {})
            # Basic sensors
            temperature = sensor_data.get('temperature', 'N/A')
            humidity = sensor_data.get('humidity', 'N/A')

            ldr_a = sensor_data.get('ldrAnalog', 'N/A')
            ldr_d = sensor_data.get('ldrDigital', 'N/A')

            # RS485 sensors
            rs_temp = sensor_data.get('rs485_temperature', 'N/A')
            rs_hum = sensor_data.get('rs485_humidity', 'N/A')
            rs_cond = sensor_data.get('rs485_conductivity', 'N/A')
            rs_ph = sensor_data.get('rs485_ph', 'N/A')

            info = disease_info.get(predicted_disease, {})
            crop_info = get_crop_info(plant_type)
            growth_stage = crop_info.get("growth_period", "N/A")
            growth_stage_translated = translate_growth_stage(growth_stage, lang)

            if lang == "ar":
                description = disease.get("description_ar", "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª")
                cause = disease.get("cause_ar", "N/A")
                treatment = disease.get("treatment_ar", "N/A")
                response = f"""
ğŸ“… *Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„:*

ğŸŒ¿ *Ø§Ù„Ù…Ø­ØµÙˆÙ„:* *{plant_type_ar}*

ğŸ¦  *Ø§Ù„Ù…Ø±Ø¶:* *{pretty_disease_name_ar}*

ğŸ“Š *Ø§Ù„Ø«Ù‚Ø©:* {confidence:.2f}%

{confidence_msg}

ğŸŒ± *Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù†Ù…Ùˆ:* {growth_stage_translated}

ğŸ“Š *Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø§Øª:*
ğŸŒ¡ï¸ Ø¯Ø±Ø¬Ø© Ø­Ø±Ø§Ø±Ø© Ø§Ù„Ù‡ÙˆØ§Ø¡: {temperature} Â°C
ğŸ’§ Ø±Ø·ÙˆØ¨Ø© Ø§Ù„Ù‡ÙˆØ§Ø¡: {humidity}%

ğŸ”¦ Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¶ÙˆØ¡ : {ldr_a}
ğŸ“º Ø´Ø¯Ø© Ø§Ù„Ø¶ÙˆØ¡: {"Ù…Ø´Ø±Ù‚" if ldr_d == 0 else "Ù…Ø¸Ù„Ù…"}

ğŸŒ¡ï¸ Ø¯Ø±Ø¬Ø© Ø­Ø±Ø§Ø±Ø© Ø§Ù„ØªØ±Ø¨Ø©: {rs_temp} Â°C
ğŸ’§ Ø±Ø·ÙˆØ¨Ø© Ø§Ù„ØªØ±Ø¨Ø©: {rs_hum}%
âš¡ Ø§Ù„ØªÙˆØµÙŠÙ„ÙŠØ© Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ© (EC): {rs_cond} ÂµS/cm
ğŸ§ª Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ù…ÙˆØ¶Ø© (pH): {rs_ph}

ğŸ’¡ *Ø§Ù„ØªÙØ§ØµÙŠÙ„:* {description}
ğŸ¤” *Ø§Ù„Ø³Ø¨Ø¨:* {cause}
ğŸ’ª *Ø§Ù„Ø¹Ù„Ø§Ø¬:* {treatment}

ğŸŒ± *Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø­Ø³Ø§Ø³Ø§Øª:*

{sensor_feedback}


ğŸ§  *Ù†ØµÙŠØ­Ø© Ø¥Ø¶Ø§ÙÙŠØ©:*
{advice}
"""
            else:
                description = disease.get("description_en", "No info")
                cause = disease.get("cause_en", "N/A")
                treatment = disease.get("treatment_en", "N/A")
                response = f"""
ğŸ“… *Analysis Result:*

ğŸŒ¿ *Plant:* {plant_type_en}
ğŸ¦  *Disease:* *{pretty_disease_name_en}*
ğŸ“Š *Confidence:* {confidence:.2f}%

{confidence_msg}

ğŸŒ± *Growth Stage:* {growth_stage}

ğŸ“Š *Sensor Data:*
ğŸŒ¡ï¸ Air Temp: {temperature} Â°C
ğŸ’§ Air Humidity: {humidity}%
ğŸ”¦ LDR Analog: {ldr_a}
ğŸ“º Light: {"Bright" if ldr_d == 0 else "Dark"}

ğŸŒ¡ï¸ Soil Temperature: {rs_temp} Â°C
ğŸ’§ Soil Humidity: {rs_hum}%
âš¡ Soil Conductivity (EC): {rs_cond} ÂµS/cm
ğŸ§ª Soil pH Level: {rs_ph}


ğŸ’¡ *Details:* {description}
ğŸ¤” *Cause:* {cause}
ğŸ’ª *Treatment:* {treatment}

ğŸŒ± *Sensor Feedback:*

{sensor_feedback}

ğŸ§  *Additional Advice:*
{advice}
"""

            bot.send_message(chat_id, response, parse_mode="Markdown")

            # Inline buttons for user actions
            keyboard = types.InlineKeyboardMarkup()
            keyboard.add(types.InlineKeyboardButton("ğŸ” Analyze Image Again", callback_data="/ChoosePlant"))
            keyboard.add(types.InlineKeyboardButton("ğŸ’¡ Get Tips", callback_data="/tips"))
            keyboard.add(types.InlineKeyboardButton("ğŸŒ Change My Language", callback_data="/language"))
            keyboard.add(types.InlineKeyboardButton("ğŸŒ± View Sensor Data", callback_data="/sensors"))

            msg_txt = "ğŸ§­ What would you like to do next?" if lang == "en" else "ğŸ§­ Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø£Ù† ØªÙØ¹Ù„ Ø¨Ø¹Ø¯ Ø°Ù„ÙƒØŸ"
            bot.send_message(chat_id, msg_txt, reply_markup=keyboard)


        else:
            msg = "âœ… Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø±Ø¶ ØªÙ… Ø§ÙƒØªØ´Ø§ÙÙ‡. Ø§Ù„Ù…Ø­ØµÙˆÙ„ ÙŠØ¨Ø¯Ùˆ ØµØ­ÙŠØ§Ù‹." if lang == "ar" else "âœ… No disease detected. Plant appears healthy."
            bot.send_message(chat_id, msg, parse_mode="Markdown")

    except Exception as e:
        bot.send_message(chat_id, "âŒ Error analyzing image. Please retry.")
        print(f"Error: {e}")

    user_choices.pop(chat_id, None)






@bot.message_handler(commands=['tips'])
def handle_tips(message):
    lang = user_languages.get(message.chat.id, 'en')  # Get the user's language (default to English)

    if lang == "ar":
        tips_text = """
ğŸŒ± *Ù†ØµØ§Ø¦Ø­ Ø§Ù„Ø¹Ù†Ø§ÙŠØ© Ø¨Ø§Ù„Ù†Ø¨Ø§ØªØ§Øª:*

ğŸ¥¬ *Ø§Ù„Ø®Ø³:* Ø³Ù‚ÙŠ Ù…Ø¹ØªØ¯Ù„ØŒ Ø¸Ù„Ø§Ù„ Ø¨Ø§Ø±Ø¯Ø©ØŒ ØªØ¬Ù†Ø¨ Ø§Ù„Ø³Ù‚ÙŠ Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰.
ğŸ¥’ *Ø§Ù„Ø®ÙŠØ§Ø±:* Ø±Ø§Ù‚Ø¨ Ø§Ù„Ø¹ÙÙ†ØŒ ØªÙ‡ÙˆÙŠØ© Ø¬ÙŠØ¯Ø©ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¨ÙŠØ¯Ø§Øª Ø§Ù„ÙØ·Ø±ÙŠØ© Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±.
ğŸ… *Ø§Ù„Ø·Ù…Ø§Ø·Ù…:* Ø£Ø´Ø¹Ø© Ø§Ù„Ø´Ù…Ø³ Ø§Ù„ÙƒØ§Ù…Ù„Ø©ØŒ ØªØ¬Ù†Ø¨ Ø§Ù„Ø¨Ù„Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ØŒ Ù‚Øµ Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø³ÙÙ„Ù‰.

ğŸ“ *Ù†ØµØ§Ø¦Ø­ Ø¥Ø¶Ø§ÙÙŠØ©:*
- Ø§Ø³ØªØ®Ø¯Ù… Ø£Ù†ÙˆØ§Ø¹ Ù…Ù‚Ø§ÙˆÙ…Ø© Ù„Ù„Ø£Ù…Ø±Ø§Ø¶ ÙƒÙ„Ù…Ø§ Ø£Ù…ÙƒÙ†.
- Ø§ÙØ­Øµ Ù†Ø¨Ø§ØªØ§ØªÙƒ Ø¨Ø§Ù†ØªØ¸Ø§Ù… Ù„Ø§ÙƒØªØ´Ø§Ù Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø±Ø¶ Ø§Ù„Ù…Ø¨ÙƒØ±Ø©.

ğŸ“… Ø§Ù„ÙØ­ÙˆØµØ§Øª Ø§Ù„Ù…Ù†ØªØ¸Ù…Ø© = Ù†Ø¨Ø§ØªØ§Øª ØµØ­ÙŠØ©! âœ¨
"""
    else:
        tips_text = """
ğŸŒ± *Plant Care Tips:*

ğŸ¥¬ *Lettuce:* Water moderately, cool shade, avoid overhead watering.
ğŸ¥’ *Cucumber:* Watch for mildew, ventilate well, use fungicides if needed.
ğŸ… *Tomato:* Full sun, no wet leaves, trim lower foliage.

ğŸ“ *Additional Tips:*
- Always use disease-resistant varieties where possible.
- Regularly inspect your plants for early signs of disease.

ğŸ“… Regular checks = healthy plants!  âœ¨
"""
    keyboard = types.InlineKeyboardMarkup()

    if lang == "ar":
      keyboard.add(types.InlineKeyboardButton("ğŸ” ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø© Ø¬Ø¯ÙŠØ¯Ø©", callback_data="/ChoosePlant"))
      keyboard.add(types.InlineKeyboardButton("ğŸŒ ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ©", callback_data="/language"))
      keyboard.add(types.InlineKeyboardButton("ğŸŒ± Ø¹Ø±Ø¶ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³", callback_data="/sensors"))
    else:
      keyboard.add(types.InlineKeyboardButton("ğŸ” Analyze Image", callback_data="/ChoosePlant"))
      keyboard.add(types.InlineKeyboardButton("ğŸŒ Change My Language", callback_data="/language"))
      keyboard.add(types.InlineKeyboardButton("ğŸŒ± View Sensor Data", callback_data="/sensors"))

      bot.reply_to(message, tips_text, parse_mode="Markdown")



# --- Start Bot ---
def start_polling():
    bot.polling(none_stop=True)

if __name__ == "__main__":
    print("ğŸš€ Bot is running...")
    threading.Thread(target=start_polling).start()

!jupyter nbconvert --to script TelegramFinal.ipynb